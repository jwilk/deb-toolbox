#!/usr/bin/python3

# Copyright © 2013-2014 Jakub Wilk <jwilk@debian.org>

# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED “AS IS” AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
# LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
# OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.

import argparse
import hashlib
import os
import subprocess as ipc
import sys

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('--method', choices=('upgrade', 'dist-upgrade'), default='dist-upgrade')
    ap.add_argument('--hash', choices=('sha1', 'sha256'), default='sha256')
    ap.add_argument('deb', nargs='+', metavar='DEB')
    options = ap.parse_args()
    cmdline = [
        'apt-get',
        options.method,
        '-o', 'Acquire::ForceHash={hash}'.format(hash=options.hash),
        '-qqy',
        '--print-uris',
    ]
    raw_expected = ipc.check_output(cmdline)
    raw_expected = raw_expected.splitlines()
    expected = {}
    for line in raw_expected:
        _, name, _, xhash = line.split()
        name = name.decode('ASCII')
        xhash = xhash.decode('ASCII').split(':')[-1].lower()
        expected[name] = xhash
    hasher = getattr(hashlib, options.hash)
    for path in options.deb:
        name = os.path.basename(path)
        try:
            xhash = expected[name]
        except LookupError:
            print('warning: {path}: not planned for upgrade'.format(path=path), file=sys.stderr)
            continue
        m = hasher()
        with open(path, 'rb') as file:
            blob = file.read()
        m.update(blob)
        ahash = m.hexdigest().lower()
        if xhash != ahash:
            print('error: {path}: hash mismatch'.format(path=path), file=sys.stderr)
            continue
        path = '/var/cache/apt/archives/{name}'.format(name=name)
        with open(path, 'xb') as file:
            file.write(blob)
        print('ok: {path}'.format(path=path), file=sys.stderr)

if __name__ == '__main__':
    main()

# vim:ts=4 sts=4 sw=4 et
