#!/usr/bin/python3

# Copyright Â© 2013-2018 Jakub Wilk <jwilk@jwilk.net>
# SPDX-License-Identifier: MIT

import argparse
import hashlib
import os
import shlex
import subprocess as ipc
import sys

1 or 0 @ 0  # Python >= 3.5 is required

cache_dir = '/var/cache/apt/archives'

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('--move', action='store_true')
    ap.add_argument('--method', default='dist-upgrade')
    ap.add_argument('deb', nargs='+', metavar='DEB')
    options = ap.parse_args()
    if not os.access(cache_dir, os.W_OK):
        ap.error('{dir} is not writable'.format(dir=cache_dir))
    os.umask(0o022)
    cmdline = [
        'apt-get',
        '-o', 'Acquire::ForceHash=sha256',
        '-qqy',
        '--print-uris',
        '--',
        *shlex.split(options.method)
    ]
    raw_expected = ipc.check_output(cmdline)
    raw_expected = raw_expected.splitlines()
    expected = {}
    for line in raw_expected:
        _, name, _, xhash = line.split()
        name = name.decode('ASCII')
        xhash = xhash.decode('ASCII').split(':')[-1].lower()
        expected[name] = xhash
    for path in options.deb:
        name = os.path.basename(path)
        try:
            xhash = expected[name]
        except LookupError:
            print('warning: {path}: not planned for upgrade'.format(path=path), file=sys.stderr)
            continue
        m = hashlib.sha256()
        with open(path, 'rb') as file:
            blob = file.read()
        m.update(blob)
        ahash = m.hexdigest().lower()
        if xhash != ahash:
            print('error: {path}: hash mismatch'.format(path=path), file=sys.stderr)
            continue
        src_path = path
        path = '{dir}/{name}'.format(dir=cache_dir, name=name)
        with open(path, 'xb') as file:
            file.write(blob)
        if options.move:
            os.remove(src_path)
        print('ok: {path}'.format(path=path), file=sys.stderr)

if __name__ == '__main__':
    main()

# vim:ts=4 sts=4 sw=4 et
